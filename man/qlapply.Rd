% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bulk.R
\name{qlapply}
\alias{enqueue_bulk}
\alias{qlapply}
\title{Run tasks in a queue}
\usage{
qlapply(X, FUN, obj, ..., envir = parent.frame(), timeout = 0,
  time_poll = 1, progress = TRUE, name = NULL, overwrite = FALSE)

enqueue_bulk(obj, X, FUN, ..., do_call = TRUE, timeout = 0, time_poll = 1,
  progress = TRUE, envir = parent.frame(), name = NULL,
  use_names = TRUE, overwrite = FALSE)
}
\arguments{
\item{X}{A vector (atomic or list) to evaluate \code{FUN} on each
element of.}

\item{FUN}{A function.  This can be a function specified by value
(e.g. \code{sin}) or by name (e.g. \code{"sin"}).  Some effort
is made to determine that the function can be found in the
environment that the queue itself uses.}

\item{obj}{The queue object.}

\item{...}{Additional arguments to pass through to \code{FUN}
along with each element of \code{X}.  Unfortunately, because of
the huge number of options that these functions support, dots
are going to be unreliable here (if you match any argument here
the dots won't make it through to your function).  This function
may adopt the (fairly ugly) convention used by \code{mapply} and
support an explicit argument instead.  Extra unfortunately
though, the dots arguments need some care so that they are
evaluated as symbols.  So another option is that all arguments
after \code{...} will acquire a leading dot.}

\item{envir}{Environment to search for functions in.  This might change.}

\item{timeout}{Time to wait for tasks to be returned.  The
default, 0, will not block but will instead return a
\code{task_bundle} object which can be used to inspect the task
status.  Give a value greater than 0 (including \code{Inf}) to
wait.  If you do wait, you can interrupt R at any time (with
Ctrl-C or Esc depending on platform) and it will return the
\code{task_bundle}.}

\item{time_poll}{How often to check for task completion.  The
default is every second.  This is an \emph{approximate} time and
should be seen as a lower limit.}

\item{progress}{Display a progress bar as tasks are polled.}

\item{name}{Name for the task bundle.  If not provided a
human-recognisable random name will be generated and printed to
the console.}

\item{overwrite}{If a task bundle name \code{name} exists already,
should we overwrite it (see \code{\link{task_bundle_create}})?
If \code{FALSE} (the default) we throw an error if it exists.}

\item{do_call}{If \code{TRUE}, rather than evaluating \code{FUN(x,
...)}, evaluate \code{FUN(x[1], x[2], ..., x[n], ...)} (where
\code{x} is an element of \code{X}).}

\item{use_names}{Only meaningful when \code{do_call} is
\code{TRUE} and \code{X} is a \code{data.frame}, if
\code{use_names = FALSE}, then names will be stripped off each row
of the data.frame before the function call is composed.}
}
\description{
A queued version of \code{\link{lapply}}.  With this, tasks are
sent to a queue (specified by \code{obj}) and run in any order,
without communication between tasks.  The functions
\code{enqueue_bulk} function is a slightly different inteface that
allows looping over rows in a data.frame as if they are parameters
to a function.
}
\details{
If the function is interrupted after all tasks have been submitted
(the progress bar will be displayed at this point) then
interrupting the process (e.g. with Ctrl-C) will return a
\code{task_bundle} object that can be queried.  Otherwise if the
timeout is reached an error will be thrown.  In either case the
tasks will continue on the cluster.
}

