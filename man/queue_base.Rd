% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/queue_base.R
\name{queue_base}
\alias{queue_base}
\title{Base class for queues}
\description{
A base class, on top of which queues can be
developed. This includes all methods except for support for
actually submitting tasks.
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{context}}{The context object}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{queue_base$new()}}
\item \href{#method-initialize_context}{\code{queue_base$initialize_context()}}
\item \href{#method-task_list}{\code{queue_base$task_list()}}
\item \href{#method-task_status}{\code{queue_base$task_status()}}
\item \href{#method-task_times}{\code{queue_base$task_times()}}
\item \href{#method-task_get}{\code{queue_base$task_get()}}
\item \href{#method-task_result}{\code{queue_base$task_result()}}
\item \href{#method-task_delete}{\code{queue_base$task_delete()}}
\item \href{#method-task_bundle_list}{\code{queue_base$task_bundle_list()}}
\item \href{#method-task_bundle_info}{\code{queue_base$task_bundle_info()}}
\item \href{#method-task_bundle_get}{\code{queue_base$task_bundle_get()}}
\item \href{#method-enqueue}{\code{queue_base$enqueue()}}
\item \href{#method-enqueue_}{\code{queue_base$enqueue_()}}
\item \href{#method-enqueue_bulk}{\code{queue_base$enqueue_bulk()}}
\item \href{#method-lapply}{\code{queue_base$lapply()}}
\item \href{#method-mapply}{\code{queue_base$mapply()}}
\item \href{#method-submit}{\code{queue_base$submit()}}
\item \href{#method-unsubmit}{\code{queue_base$unsubmit()}}
\item \href{#method-clone}{\code{queue_base$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Constructor
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{queue_base$new(context_id, root = NULL, initialize = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{context_id}}{A context identifier; either a context
object or an name/id of a saved context (see
\code{\link[context:context_save]{context::context_save()}}).}

\item{\code{root}}{Root path to load contexts from, if using a string
identifier for \code{context_id}. If \code{context_id} is a \code{context}
object then \code{root} must be \code{NULL}.}

\item{\code{initialize}}{Logical, indicating if the context should be
loaded immediately. If you want to run tasks this must be
\code{TRUE}, but to query it can be \code{FALSE}. See
\code{\link[context:context_load]{context::context_load()}} and the \verb{$initialise_context()} method.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-initialize_context"></a>}}
\if{latex}{\out{\hypertarget{method-initialize_context}{}}}
\subsection{Method \code{initialize_context()}}{
Load the context. This causes the packages to be
loaded and all script files to be sourced. This is required
before any tasks can be queued, because we need to be check
against this environment to work out what is available on
any workers.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{queue_base$initialize_context()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-task_list"></a>}}
\if{latex}{\out{\hypertarget{method-task_list}{}}}
\subsection{Method \code{task_list()}}{
List all tasks known to this queue
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{queue_base$task_list()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-task_status"></a>}}
\if{latex}{\out{\hypertarget{method-task_status}{}}}
\subsection{Method \code{task_status()}}{
Return the status of selected tasks
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{queue_base$task_status(task_ids = NULL, named = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task_ids}}{Task identifiers to query. If \code{NULL}, then all
tasks are queried.}

\item{\code{named}}{Logical, indicating if the status result should be
named by by task id.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-task_times"></a>}}
\if{latex}{\out{\hypertarget{method-task_times}{}}}
\subsection{Method \code{task_times()}}{
Return the times taken by tasks as a \link{data.frame}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{queue_base$task_times(task_ids = NULL, unit_elapsed = "secs", sorted = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task_ids}}{Task identifiers to query. If \code{NULL}, then all
tasks are queried.}

\item{\code{unit_elapsed}}{Time unit to use for the elapsed fields}

\item{\code{sorted}}{Logical indicating of the fields should be sorted
by submitted time.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-task_get"></a>}}
\if{latex}{\out{\hypertarget{method-task_get}{}}}
\subsection{Method \code{task_get()}}{
Retrieve a task by id
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{queue_base$task_get(task_id, check_exists = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task_id}}{A task identifier (hexadecimal string)}

\item{\code{check_exists}}{Logical, indicating if we should check
that the task exists.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-task_result"></a>}}
\if{latex}{\out{\hypertarget{method-task_result}{}}}
\subsection{Method \code{task_result()}}{
Retrieve a task's result
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{queue_base$task_result(task_id)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task_id}}{A task identifier (hexadecimal string)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-task_delete"></a>}}
\if{latex}{\out{\hypertarget{method-task_delete}{}}}
\subsection{Method \code{task_delete()}}{
Delete tasks
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{queue_base$task_delete(task_ids)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task_ids}}{A vector of task identifiers (each a
hexadecimal string)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-task_bundle_list"></a>}}
\if{latex}{\out{\hypertarget{method-task_bundle_list}{}}}
\subsection{Method \code{task_bundle_list()}}{
List all known task bundles
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{queue_base$task_bundle_list()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-task_bundle_info"></a>}}
\if{latex}{\out{\hypertarget{method-task_bundle_info}{}}}
\subsection{Method \code{task_bundle_info()}}{
List all known task bundles along with information
about what was run and when.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{queue_base$task_bundle_info()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-task_bundle_get"></a>}}
\if{latex}{\out{\hypertarget{method-task_bundle_get}{}}}
\subsection{Method \code{task_bundle_get()}}{
Get a task bundle by name
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{queue_base$task_bundle_get(name)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{A task bundle identifier (a string of the form
\code{adjective_anmimal})}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-enqueue"></a>}}
\if{latex}{\out{\hypertarget{method-enqueue}{}}}
\subsection{Method \code{enqueue()}}{
Queue a task
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{queue_base$enqueue(expr, envir = parent.frame(), submit = TRUE, name = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{expr}}{An unevaluated expression to put on the queue}

\item{\code{envir}}{The environment that you would run this expression in
locally. This will be used to copy across any dependent variables.
For example, if your expression is \code{sum(1 + a)}, we will also send
the value of \code{a} to the worker along with the expression.}

\item{\code{submit}}{Logical indicating if the task should be submitted}

\item{\code{name}}{Optional name for the task}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-enqueue_"></a>}}
\if{latex}{\out{\hypertarget{method-enqueue_}{}}}
\subsection{Method \code{enqueue_()}}{
Queue a task
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{queue_base$enqueue_(expr, envir = parent.frame(), submit = TRUE, name = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{expr}}{A quoted expression to put on the queue}

\item{\code{envir}}{The environment that you would run this expression in
locally. This will be used to copy across any dependent variables.
For example, if your expression is \code{sum(1 + a)}, we will also send
the value of \code{a} to the worker along with the expression.}

\item{\code{submit}}{Logical indicating if the task should be submitted}

\item{\code{name}}{Optional name for the task}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-enqueue_bulk"></a>}}
\if{latex}{\out{\hypertarget{method-enqueue_bulk}{}}}
\subsection{Method \code{enqueue_bulk()}}{
Send a bulk set of tasks to your workers.
This function is a bit like a mash-up of \link{Map} and \link{do.call},
when used with a \link{data.frame} argument, which is typically what
is provided. Rather than \verb{$lapply()} which applies \code{FUN} to each
element of \code{X}, \verb{enqueue_bulk will apply over each row of }X\verb{, spreading the columms out as arguments. If you have a function }f(a, b)\verb{and a [data.frame] with columns}a\code{and}b` this
should feel intuitive.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{queue_base$enqueue_bulk(
  X,
  FUN,
  ...,
  do_call = TRUE,
  envir = parent.frame(),
  timeout = 0,
  time_poll = 1,
  progress = NULL,
  name = NULL,
  overwrite = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{X}}{Typically a \link{data.frame}, which you want to apply \code{FUN}
over, row-wise. The names of the \code{data.frame} must match the
arguments of your function.}

\item{\code{FUN}}{A function}

\item{\code{...}}{Additional arguments to add to every call to \code{FUN}}

\item{\code{do_call}}{Logical, indicating if each row of \code{X} should be
treated as if it was \code{do.call(FUN, X[i, ])} - typically this is what
you want.}

\item{\code{envir}}{The environment to use to try and find the function}

\item{\code{timeout}}{Optional timeout, in seconds, after which an
error will be thrown if the task has not completed.}

\item{\code{time_poll}}{Optional time with which to "poll" for
completion.}

\item{\code{progress}}{Optional logical indicating if a progress bar
should be displayed. If \code{NULL} we fall back on the value of the
global option \code{rrq.progress}, and if that is unset display a
progress bar if in an interactive session.}

\item{\code{name}}{Optional name for a created bundle}

\item{\code{overwrite}}{Logical, indicating if we should overwrite any
bundle that exists with name \code{name}.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-lapply"></a>}}
\if{latex}{\out{\hypertarget{method-lapply}{}}}
\subsection{Method \code{lapply()}}{
Apply a function over a list of data. This is
equivalent to using \verb{$enqueue()} over each element in the list.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{queue_base$lapply(
  X,
  FUN,
  ...,
  envir = parent.frame(),
  timeout = 0,
  time_poll = 1,
  progress = NULL,
  name = NULL,
  overwrite = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{X}}{A list of data to apply our function against}

\item{\code{FUN}}{A function to be applied to each element of \code{X}}

\item{\code{...}}{Additional arguments to add to every call to \code{FUN}}

\item{\code{envir}}{The environment to use to try and find the function}

\item{\code{timeout}}{Optional timeout, in seconds, after which an
error will be thrown if the task has not completed.}

\item{\code{time_poll}}{Optional time with which to "poll" for
completion.}

\item{\code{progress}}{Optional logical indicating if a progress bar
should be displayed. If \code{NULL} we fall back on the value of the
global option \code{rrq.progress}, and if that is unset display a
progress bar if in an interactive session.}

\item{\code{name}}{Optional name for a created bundle}

\item{\code{overwrite}}{Logical, indicating if we should overwrite any
bundle that exists with name \code{name}.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-mapply"></a>}}
\if{latex}{\out{\hypertarget{method-mapply}{}}}
\subsection{Method \code{mapply()}}{
A wrapper like \code{mapply}


Send a bulk set of tasks to your workers.
This function is a bit like a mash-up of \link{Map} and \link{do.call},
when used with a \link{data.frame} argument, which is typically what
is provided. Rather than \verb{$lapply()} which applies \code{FUN} to each
element of \code{X}, \verb{enqueue_bulk will apply over each row of }X\verb{, spreading the columms out as arguments. If you have a function }f(a, b)\verb{and a [data.frame] with columns}a\code{and}b` this
should feel intuitive.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{queue_base$mapply(
  FUN,
  ...,
  MoreArgs = NULL,
  envir = parent.frame(),
  timeout = 0,
  time_poll = 1,
  progress = NULL,
  name = NULL,
  use_names = TRUE,
  overwrite = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{FUN}}{A function}

\item{\code{...}}{Additional arguments to add to every call to \code{FUN}}

\item{\code{MoreArgs}}{As for \link{mapply}, additional arguments that apply
to every function call.}

\item{\code{envir}}{The environment to use to try and find the function}

\item{\code{timeout}}{Optional timeout, in seconds, after which an
error will be thrown if the task has not completed.}

\item{\code{time_poll}}{Optional time with which to "poll" for
completion.}

\item{\code{progress}}{Optional logical indicating if a progress bar
should be displayed. If \code{NULL} we fall back on the value of the
global option \code{rrq.progress}, and if that is unset display a
progress bar if in an interactive session.}

\item{\code{name}}{Optional name for a created bundle}

\item{\code{use_names}}{Use names}

\item{\code{overwrite}}{Logical, indicating if we should overwrite any
bundle that exists with name \code{name}.}

\item{\code{X}}{Typically a \link{data.frame}, which you want to apply \code{FUN}
over, row-wise. The names of the \code{data.frame} must match the
arguments of your function.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-submit"></a>}}
\if{latex}{\out{\hypertarget{method-submit}{}}}
\subsection{Method \code{submit()}}{
Submit a task into a queue. This is a stub
method and must be overridden by a derived class for the queue
to do anything.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{queue_base$submit(task_ids, names = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task_ids}}{Vector of tasks to submit}

\item{\code{names}}{Optional vector of names of tasks}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-unsubmit"></a>}}
\if{latex}{\out{\hypertarget{method-unsubmit}{}}}
\subsection{Method \code{unsubmit()}}{
Unsubmit a task from the queue.  This is a stub
method and must be overridden by a derived class for the queue
to do anything.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{queue_base$unsubmit(task_ids)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task_ids}}{Vector of tasks to submit}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{queue_base$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
